### 구간 합 
> 합 배열을 이용하여 시간 복잡도를 더 줄이기 위해 사용하는 특수 목적의 알고리즘

핵심 이론
- 합 배열을 구해야 한다.
  - ex) 배열 A가 있을 대 합 배열 S
  - S[i] = A[0] + A[1] + A[2] + ... A[i-1] + A[i]
  - 힙 배열 공식 : S[i] = S[i-1] A[i]
- 구간 합 공식
  - S[j] - S[i-1] // i에서 j까지의 구간 합

시간 복잡도
- 합 배열을 통해 O(1)
- 최악의 경우 O(N)

---

### 투 포인터
> 배열 또는 연결리스트 등 순서가 있는 데이터 구조에서 사용하는 알고리즘

기능
- 두 개의 포인터를 사용하여 배열 또는 리스트의 요소를 효율적으로 탐색하는 것
    - 두 개의 포인터 : 처음부터 시작하는 포인터, 끝에서 시작하는 포인터

특징
- 정렬된 배열이나 리스트에서 사용할 경우 효율적

시간 복잡도
- O(n)

문제 유형
- 배열에서 두 요소의 합이 타겟인 경우 찾기
- 배열에서 주어진 조건을 만족하는 연속된 부분 배열 찾기
- 배열에서 주어진 값 k와 가장 가까운 값 찾기
- 배열에서 주어진 값 k보다 작거나 같은 값 중에서 가장 큰 값 찾기
- 배열에서 주어진 값 k보다 크거나 같은 값 중에서 가장 작은 값 찾기
- 배열에서 주어진 값 k보다 작은 값을 제거한 배열 반환하기

---

### 슬라이딩 윈도우
> 배열, 문자열, 리스트 등의 연속적인 데이터 구조에서 사용되며, 
> 특정 구간을 이동하면서 문제를 해결하는 방법

기능
- 고정된 길이이 윈도우를 이동시키면서 문제를 해결
  - 윈도우 : 데이터 구조에서 일정한 크기의 부분집합을 의미
  - ex) 문자열에서 길이가 k인 윈도우를 이동시키면서 문제를 해결

특징
- 두 개의 포인터를 사용
  - 시작 포인터, 끝 포인터
- Deque 자료구조 이용 (양방향 삽입/삭제 가능)

시간 복잡도
- O(n)

문제 유형
- 배열에서 연속된 부분 배열 중에서 최대/최소 값을 찾기
- 문자열에서 연속된 부분 문자열 중에서 최대/최소 값을 찾기
- 배열에서 연속된 k개의 요소의 합 중에서 최대/최소 값을 찾기
- 문자열에서 연속된 k개의 문자열의 합 중에서 최대/최소 값을 찾기
- 배열에서 특정 조건을 만족하는 연속된 부분 배열 찾기
- 문자열에서 특정 조건을 만족하는 연속된 부분 문자열 찾기

---

### 정렬

**버블정렬(bubble)**
> 데이터의 인접 요소끼리 비교하고, swap 연산을 수행하며 정렬하는 방식

시간 복잡도 : O(n^2)

**선택 정렬(selection)**
> 대상에서 가장 크거나 작은 데이터를 찾아가 선택을 반복하면서 정렬하는 방식

시간 복잡도 : O(n^2)

**삽입 정렬(insertion)**
> 대상을 선택해 정렬된 영역에서 선택 데이터를 적절한 위치를 찾아 삽입하면서 정렬하는 방식

시간 복잡도 : O(n^2)

**퀵 정렬(quick)**
> pivot 값을 선정해 해당 값을 기준으로 정렬하는 방식

시간 복잡도 : 평균 시간 복잡도 O(nlogn), 최악의 경우 O(n^2)

**병합 정렬 (merge)**
> 이미 정렬된 부분 집합들을 효율적으로 병합해 전체를 정렬하는 방식

시간 복잡도 : O(nlogn)

**기수 정렬 (radix)**
> 데이터의 자릿수를 바탕으로 비교할 데이터를 정렬하는 방식

시간 복잡도 : O(k*n)

**계수 정렬(Counting Sort)**
> 입력된 데이터의 크기를 기반으로 데이터를 정렬하는 방식

시간 복잡도 : O(n + k) - n은 입력 크기, k는 입력의 최대값

---

### 깊이우선탐색 DFS
> DFS(Depth-First Search)  
> 그래프의 완전 탐색 기법 중 하나  
> 그래프의 시작 노드에서 출발하여 탐색할 한 쪽 분기를 정하여 최대 깊이까지 탐색을 마친 후
> 다른 쪽 분기로 이동하여 다시 탐색을 수행하는 알고리즘

기능
- 그래프 완전 탐색

특징
- 재귀 함수로 구현
  - 주로 사용
  - 스택 오버플로 유의
- 스택 자료구조 이용 (LIFO, 후입선출)

시간 복잡도
- O(V + E) (노드 수: V, 엣지 수: E)

깊이 우선 탐색 과정
1. DFS를 시작할 노드를 정한 후 사용할 자료구조 초기화
2. 노드의 방문 여부를 체크할 자료구조 초기화
3. DFS 수행 : 현재 노드의 연결 노드 중 방문하지 않은 노드 대상으로 DFS 실행

문제 유형
> 가장 깊은 경로를 탐색하는 문제나, 그래프에서 특정한 노드를 찾는 문제 등에 사용
- 단절점 찾기, 단절선 찾기, 사이클 찾기, 위상 정렬
- 그래프에서 특정한 노드를 찾는 문제
- 그래프에서 경로가 존재하는지 여부를 판별하는 문제
- 그래프에서 모든 노드를 탐색하는 문제
- 그래프에서 사이클을 찾는 문제
- 그래프에서 연결 요소를 찾는 문제
- 그래프에서 강한 연결 요소를 찾는 문제
- 미로 찾기와 같은 게임에서 가장 짧은 경로를 찾는 문제

---

### 너비우선탐색 BFS
> BFS(Breadth-First Search)  
> 그래프를 완전 탐색하는 방법 중 하나  
> 시작 노드에서 출발해 시작 노드를 기준으로 가까운 노드를 먼저 방문하면서 탐색하는 알고리즘

기능
- 그래프 완전 탐색

특징
- FIFO 탐색 (선입선출)
- Queue 자료구조 이용
- 시작 노드와 가까운 노드를 우선하여 탐색하므로 목표 노드에 도착하는 경로가 여러 개일 때 최단 경로를 보장한다.

너비 우선 탐색 과정
1. BFS를 시작할 노드를 정한 후 사용할 자료구조 초기화
2. 큐에서 노드를 꺼낸 후 꺼낸 노드의 인접 노드를 다시 큐에 삽입
   - 중복 방문 방지를 위해 노드의 방문 여부 체크
3. 큐 자료구조에 값이 없을 때까지 반복

문제 유형
> 가장 짧은 거리를 구하는 문제나, 특정한 조건을 만족하는 가장 빠른 경로를 구하는 문제 등에 사용
- 그래프에서 최단 경로 찾기
- 그래프에서 특정한 조건을 만족하는 경로 찾기
- 그래프에서 모든 노드를 탐색하는 문제
- 퍼즐과 같은 게임에서 최소 이동 횟수를 찾는 문제
- 너비가 큰 트리에서 가장 왼쪽에 있는 노드를 찾는 문제
- 컴파일러에서 소스 코드의 문법을 검사하는 문제
- 그래프에서 사이클을 찾는 문제

---

### 이진탐색
> 데이터가 정렬돼 있는 상태에서 원하는 값을 찾아내는 알고리즘

기능
- 타깃 데이터 검색

특징
- 중앙값 비교를 통한 대상 충소 방식
  - 대상 데이터의 중앙값과 찾고자 하는 값을 비교해 데이터의 크기를 절반씩 줄이면서 대상을 찾는다.
- 이진 탐색은 데이터가 정렬되어있어야 한다.

시간 복잡도
- O(logN)

이진 탐색 과정
1. 현재 데이터셋의 중앙값을 선택한다
2. 중앙값 > 타깃 데이터일 때 중앙값 기준으로 왼쪽 데이터셋을 선택한다.
3. 중앙값 < 타깃 데이터 일때 중앙값 기준으로 오른쪽 데이터셋을 선택한다.
4. 과정 1~3 반복 중 중앙값 == 타깃 데이터일 때 탐색 종료

---

### 그리디 (Greedy)
> 현재 상태에서 보는 선택지 중 최선의 선택지가 전체 선택지 중 최선의 선택지라고 가정하는 알고리즘


그리디 알고리즘 수행 과정
1. 해 선택 : 현재 상태에서 가장 최선이라고 생각되는 해를 선택한다.
2. 직절성 검사 : 현재 선택한 해가 전체 문제의 제약 조건에 벗어나지 않는지 검사한다.
3. 해 검사 : 현재까지 선택한 해 집합이 전체 문제를 해결할 수 있는지 검사한다. 전체문제를 핵려하지 못한다면 다시 1로 돌아가 같은 과정 반복

---

### 소수구하기
> 소수(prime number)는 자신보다 작은 2개의 자연수를 곱해 만들 수 없는 1보다 큰 자연수를 말한다.
> 즉, 1과 자기 자신 이외에 약소가 존재하지 않는 수를 말한다.

소수 판별법 - 에라토스테네스의 체
1. 구하고자 하는 소수의 범위만틈 1차원 배열을 생성한다.
2. 숫자 2부터 시작, 선택된 숫자의 배수에 해당하는 수를 배열에서 끝까지 탐색하며 지운다. 이때 처음으로 선택된 숫지는 지우지 않는다.
3. 배열의 끝까지 2.를 반복한 후 배열에서 남아 있는 모든 수를 출력한다.

시간 복잡도
- O(N^2), 일반적으로 O(Nlog(logN))

---

### 유니온 파인드
> 여러 노드가 있을 때 특정 2개의 노드를 연결해 1개의 집합으로 묶는 ```union``` 연산과,
> 두 노드가 있을때 같은 집합에 속해 있는지를 확인하는 ```find``` 연산으로 구성되어 있는 알고리즘

**union, find 연산**
- union 연산 : 각 노드가 속한 집합을 1개로 합치는 연산
  - 일반적인 방법 : 1차원 배열 이용
- find 연산 : 특정 노드 a에 관해 a가 속한 집합의 대표 노드를 반환하는 연산

**find 연산 작동 원리**
1. 대상 노드 배열에 index값과 value값이 동일한지 확인
2. 동일하지 않으면 value값이 가리키는 index위치로 이동
3. 이동 위치의 index값과 value값이 같을 때까지 1.~2.반복. (재귀함수로 구현)
4. 대표 노드에 도달하면 재귀 함수를 빠져나오면서 거치는 모든 노드값을 루트 노드값으로 변경

유의
- find 연산을 수행할때 재귀함수를 빠져나오면서 탐색한 모든 노드의 대표 노드값을 루트 노드값으로 변경해야한다.
- union 연산에서 선택된 노드끼리 연결해야한다.

시간 복잡도
- 일반적으로 O(n), 최악의 경우 O(n^2)

---

### 위상정렬
> 사이클 없는 방향 그래프에서 노드 순서를 찾는 알고리즘

기능
- 노드 간의 순서를 결정

특징
- 사이클이 없어야 한다.
  - 사이클이 존재하면 노드 간의 순서를 명확하게 정의할 수 없다.
- 항상 유일한 값으로 정렬되지 않는다. 

시간 복잡도
- O(V + E) (노드 수: V, 엣지 수: E)

---

### 다익스트라
> 그래프에서 최단 거리를 구하는 알고리즘

기능
- 출발 노드와 모든 노드간의 거리 탐색  

특징 
- 엣지는 모두 양수

시간 복잡도
- O(ElogV) (노드 수: V, 엣지 수: E)

---

### 벨만-포드
> 그래프에서 최단 거리를 구하는 알고리즘

기능
- 특정출발 노드에서 다른 모든 노드까지의 최단 경로 탐색

특징
- 음수 가중치 엣지가 있어도 수행할 수 있다.
- 전체 그래프에서 음수 사이클의 존재 여부 판단 가능

시간복잡도
- O(VE) (노드 수: V, 엣지 수: E)

---

### 플로이드-워셜
> 그래프에서 최단 거리를 구하는 알고리즘

기능
- 모든 노드 간에 최단 경로 탐색

특징
- 음수 가중치 엣지가 있어도 수행할 수 있다.
- 동적 계획법의 원리를 이용해 알고리즘에 접근

시간 복잡도
- O(V^3) (노드 수 : V)

---

### 최소 신장 트리



---


### 세그먼트 트리

---


### 최소 공통 조상

---


### 조합


---


### 동적계획법(다이나믹프로그래밍, DP)
> 복잡한 문제를 여러 개의 간단한 문제로 분리하여 부분의 문제들을 해결함으로써 최종적으로 복잡한 문제의 답을 구하는 방법

동적계획법 원리와 구현 방식
1. 큰 문제를 작은 문제로 나눌 수 있어야 한다.
2. 작은 문제들이 반복돼 나타나고 사용되며 이 작은 문제들의 결과 값은 항상 같아야 한다.
3. 모든 작은 문제들은 한 번만 계산해 DP 테이블에 저장하며 추후 재사용할 때는 이 DP 테이블을 이용한다. (메모이제이션 기법)
4. 동적 계획법은 톱-다운(top-down)방식과 바텁-업(bottom-up)방식으로 구현할 수 있다.

대표적인 동적계획법 문제 - **피보나치 수열 공식**
- D[N] = D[N-1] + D[N-2]; // N번째 수열 = N-1번째 수열 + N-2번째 수열


---
