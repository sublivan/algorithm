### 구간 합 
> 합 배열을 이용하여 시간 복잡도를 더 줄이기 위해 사용하는 특수 목적의 알고리즘

핵심 이론
- 합 배열을 구해야 한다.
  - ex) 배열 A가 있을 대 합 배열 S
  - S[i] = A[0] + A[1] + A[2] + ... A[i-1] + A[i]
  - 힙 배열 공식 : S[i] = S[i-1] A[i]
- 구간 합 공식
  - S[j] - S[i-1] // i에서 j까지의 구간 합

시간 복잡도
- 합 배열을 통해 O(1)
- 최악의 경우 O(N)

---

### 투 포인터
> 배열 또는 연결리스트 등 순서가 있는 데이터 구조에서 사용하는 알고리즘

기능
- 두 개의 포인터를 사용하여 배열 또는 리스트의 요소를 효율적으로 탐색하는 것
    - 두 개의 포인터 : 처음부터 시작하는 포인터, 끝에서 시작하는 포인터

특징
- 정렬된 배열이나 리스트에서 사용할 경우 효율적

시간 복잡도
- O(n)

문제 유형
- 배열에서 두 요소의 합이 타겟인 경우 찾기
- 배열에서 주어진 조건을 만족하는 연속된 부분 배열 찾기
- 배열에서 주어진 값 k와 가장 가까운 값 찾기
- 배열에서 주어진 값 k보다 작거나 같은 값 중에서 가장 큰 값 찾기
- 배열에서 주어진 값 k보다 크거나 같은 값 중에서 가장 작은 값 찾기
- 배열에서 주어진 값 k보다 작은 값을 제거한 배열 반환하기

---

### 슬라이딩 윈도우
> 배열, 문자열, 리스트 등의 연속적인 데이터 구조에서 사용되며, 
> 특정 구간을 이동하면서 문제를 해결하는 방법

기능
- 고정된 길이이 윈도우를 이동시키면서 문제를 해결
  - 윈도우 : 데이터 구조에서 일정한 크기의 부분집합을 의미
  - ex) 문자열에서 길이가 k인 윈도우를 이동시키면서 문제를 해결

특징
- 두 개의 포인터를 사용
  - 시작 포인터, 끝 포인터
- Deque 자료구조 이용 (양방향 삽입/삭제 가능)

시간 복잡도
- O(n)

문제 유형
- 배열에서 연속된 부분 배열 중에서 최대/최소 값을 찾기
- 문자열에서 연속된 부분 문자열 중에서 최대/최소 값을 찾기
- 배열에서 연속된 k개의 요소의 합 중에서 최대/최소 값을 찾기
- 문자열에서 연속된 k개의 문자열의 합 중에서 최대/최소 값을 찾기
- 배열에서 특정 조건을 만족하는 연속된 부분 배열 찾기
- 문자열에서 특정 조건을 만족하는 연속된 부분 문자열 찾기

---

### 정렬

**버블정렬(bubble)**
> 데이터의 인접 요소끼리 비교하고, swap 연산을 수행하며 정렬하는 방식

시간 복잡도 : O(n^2)

**선택 정렬(selection)**
> 대상에서 가장 크거나 작은 데이터를 찾아가 선택을 반복하면서 정렬하는 방식

시간 복잡도 : O(n^2)

**삽입 정렬(insertion)**
> 대상을 선택해 정렬된 영역에서 선택 데이터를 적절한 위치를 찾아 삽입하면서 정렬하는 방식

시간 복잡도 : O(n^2)

**퀵 정렬(quick)**
> pivot 값을 선정해 해당 값을 기준으로 정렬하는 방식

시간 복잡도 : 평균 시간 복잡도 O(nlogn), 최악의 경우 O(n^2)

**병합 정렬 (merge)**
> 이미 정렬된 부분 집합들을 효율적으로 병합해 전체를 정렬하는 방식

시간 복잡도 : O(nlogn)

**기수 정렬 (radix)**
> 데이터의 자릿수를 바탕으로 비교할 데이터를 정렬하는 방식

시간 복잡도 : O(k*n)

**계수 정렬(Counting Sort)**
> 입력된 데이터의 크기를 기반으로 데이터를 정렬하는 방식

시간 복잡도 : O(n + k) - n은 입력 크기, k는 입력의 최대값

---

### 깊이우선탐색 DFS
> DFS(Depth-First Search)  
> 그래프의 완전 탐색 기법 중 하나  
> 그래프의 시작 노드에서 출발하여 탐색할 한 쪽 분기를 정하여 최대 깊이까지 탐색을 마친 후
> 다른 쪽 분기로 이동하여 다시 탐색을 수행하는 알고리즘

기능
- 그래프 완전 탐색

특징
- 재귀 함수로 구현
  - 주로 사용
  - 스택 오버플로 유의
- 스택 자료구조 이용 (LIFO, 후입선출)

시간 복잡도
- O(V + E) (노드 수: V, 엣지 수: E)

깊이 우선 탐색 과정
1. DFS를 시작할 노드를 정한 후 사용할 자료구조 초기화
2. 노드의 방문 여부를 체크할 자료구조 초기화
3. DFS 수행 : 현재 노드의 연결 노드 중 방문하지 않은 노드 대상으로 DFS 실행

문제 유형
> 가장 깊은 경로를 탐색하는 문제나, 그래프에서 특정한 노드를 찾는 문제 등에 사용
- 단절점 찾기, 단절선 찾기, 사이클 찾기, 위상 정렬
- 그래프에서 특정한 노드를 찾는 문제
- 그래프에서 경로가 존재하는지 여부를 판별하는 문제
- 그래프에서 모든 노드를 탐색하는 문제
- 그래프에서 사이클을 찾는 문제
- 그래프에서 연결 요소를 찾는 문제
- 그래프에서 강한 연결 요소를 찾는 문제
- 미로 찾기와 같은 게임에서 가장 짧은 경로를 찾는 문제

---

### 너비우선탐색 BFS
> BFS(Breadth-First Search)  
> 그래프를 완전 탐색하는 방법 중 하나  
> 시작 노드에서 출발해 시작 노드를 기준으로 가까운 노드를 먼저 방문하면서 탐색하는 알고리즘

기능
- 그래프 완전 탐색

특징
- FIFO 탐색 (선입선출)
- Queue 자료구조 이용
- 시작 노드와 가까운 노드를 우선하여 탐색하므로 목표 노드에 도착하는 경로가 여러 개일 때 최단 경로를 보장한다.

너비 우선 탐색 과정
1. BFS를 시작할 노드를 정한 후 사용할 자료구조 초기화
2. 큐에서 노드를 꺼낸 후 꺼낸 노드의 인접 노드를 다시 큐에 삽입
   - 중복 방문 방지를 위해 노드의 방문 여부 체크
3. 큐 자료구조에 값이 없을 때까지 반복

문제 유형
> 가장 짧은 거리를 구하는 문제나, 특정한 조건을 만족하는 가장 빠른 경로를 구하는 문제 등에 사용
- 그래프에서 최단 경로 찾기
- 그래프에서 특정한 조건을 만족하는 경로 찾기
- 그래프에서 모든 노드를 탐색하는 문제
- 퍼즐과 같은 게임에서 최소 이동 횟수를 찾는 문제
- 너비가 큰 트리에서 가장 왼쪽에 있는 노드를 찾는 문제
- 컴파일러에서 소스 코드의 문법을 검사하는 문제
- 그래프에서 사이클을 찾는 문제

---

### 이진탐색
> 데이터가 정렬돼 있는 상태에서 원하는 값을 찾아내는 알고리즘

기능
- 타깃 데이터 검색

특징
- 중앙값 비교를 통한 대상 충소 방식
  - 대상 데이터의 중앙값과 찾고자 하는 값을 비교해 데이터의 크기를 절반씩 줄이면서 대상을 찾는다.
- 이진 탐색은 데이터가 정렬되어있어야 한다.

시간 복잡도
- O(logN)

이진 탐색 과정
1. 현재 데이터셋의 중앙값을 선택한다
2. 중앙값 > 타깃 데이터일 때 중앙값 기준으로 왼쪽 데이터셋을 선택한다.
3. 중앙값 < 타깃 데이터 일때 중앙값 기준으로 오른쪽 데이터셋을 선택한다.
4. 과정 1~3 반복 중 중앙값 == 타깃 데이터일 때 탐색 종료

---

### 그리디 (Greedy)
> 현재 상태에서 보는 선택지 중 최선의 선택지가 전체 선택지 중 최선의 선택지라고 가정하는 알고리즘


그리디 알고리즘 수행 과정
1. 해 선택 : 현재 상태에서 가장 최선이라고 생각되는 해를 선택한다.
2. 직절성 검사 : 현재 선택한 해가 전체 문제의 제약 조건에 벗어나지 않는지 검사한다.
3. 해 검사 : 현재까지 선택한 해 집합이 전체 문제를 해결할 수 있는지 검사한다. 전체문제를 핵려하지 못한다면 다시 1로 돌아가 같은 과정 반복

---

### 소수구하기
> 소수(prime number)는 자신보다 작은 2개의 자연수를 곱해 만들 수 없는 1보다 큰 자연수를 말한다.
> 즉, 1과 자기 자신 이외에 약소가 존재하지 않는 수를 말한다.

소수 판별법 - 에라토스테네스의 체
1. 구하고자 하는 소수의 범위만틈 1차원 배열을 생성한다.
2. 숫자 2부터 시작, 선택된 숫자의 배수에 해당하는 수를 배열에서 끝까지 탐색하며 지운다. 이때 처음으로 선택된 숫지는 지우지 않는다.
3. 배열의 끝까지 2.를 반복한 후 배열에서 남아 있는 모든 수를 출력한다.

시간 복잡도
- O(N^2), 일반적으로 O(Nlog(logN))

---

### 유니온 파인드
> 여러 노드가 있을 때 특정 2개의 노드를 연결해 1개의 집합으로 묶는 ```union``` 연산과,
> 두 노드가 있을때 같은 집합에 속해 있는지를 확인하는 ```find``` 연산으로 구성되어 있는 알고리즘

**union, find 연산**
- union 연산 : 각 노드가 속한 집합을 1개로 합치는 연산
  - 일반적인 방법 : 1차원 배열 이용
- find 연산 : 특정 노드 a에 관해 a가 속한 집합의 대표 노드를 반환하는 연산

**find 연산 작동 원리**
1. 대상 노드 배열에 index값과 value값이 동일한지 확인
2. 동일하지 않으면 value값이 가리키는 index위치로 이동
3. 이동 위치의 index값과 value값이 같을 때까지 1.~2.반복. (재귀함수로 구현)
4. 대표 노드에 도달하면 재귀 함수를 빠져나오면서 거치는 모든 노드값을 루트 노드값으로 변경

유의
- find 연산을 수행할때 재귀함수를 빠져나오면서 탐색한 모든 노드의 대표 노드값을 루트 노드값으로 변경해야한다.
- union 연산에서 선택된 노드끼리 연결해야한다.

시간 복잡도
- 일반적으로 O(n), 최악의 경우 O(n^2)

---

### 위상정렬
> 사이클 없는 방향 그래프에서 노드 순서를 찾는 알고리즘

기능
- 노드 간의 순서를 결정

특징
- 사이클이 없어야 한다.
  - 사이클이 존재하면 노드 간의 순서를 명확하게 정의할 수 없다.
- 항상 유일한 값으로 정렬되지 않는다.

시간 복잡도
- O(V + E) (노드 수: V, 엣지 수: E)

핵심 이론
1. 인접리스트로 그래프 구현하기
   - 인접리스트 ArrayList<ArrayList<Integer>
2. 진입 차수 배열 초기화
   - 진입 차수 저장 배열 D[N] 
   - 진입 차수(in-degree) : 자기 자신을 가리키는 엣지의 개수
3. 진입 차수가 0인 노드를 선택하고 선택된 노드를 위상 정렬 배열(정답 배열)에 저장
   - 그 후 인접 리스트에서 선택된 노드가 가리키는 노드들의 진입 차수를 1씩 뺀다.

---

### 다익스트라
> 그래프에서 최단 거리를 구하는 알고리즘  
> 즉, 출발 노드와 그외 노드 간의 최단 거리를 구하는 알고리즘

기능
- 출발 노드와 모든 노드간의 거리 탐색  

특징 
- 엣지는 가중치는 모두 양수

시간 복잡도
- O(ElogV) (노드 수: V, 엣지 수: E)

핵심이론
1. 인접 리스트로 그래프 구현하기
   - 시간 복잡도 측면, N의 크기가 클 것을 대비해 인접 리스트를 선택해서 구현하는것이 좋다.
   - 인접 리스트에 연결한 배열의 자료형은 (노드, 가중치)형태
     - ArrayList<Edge>[]
2. 최단 거리 배열 초기화하기
   - 최단 거리 배열을 만들고, 출발 노드는 0, 이외의 노드는 무한(적당히 큰값)으로 초기화
3. 값이 가장 작은 노드 고르기
   - 최단 거리 배열에서 현재 값이 가장 작은 노들르 고른다.
4. 최단 거리 배열 업데이트 하기
   - Min(선택 노드의 최단 거리 배열의 값 + 엣지 가중치, 연결 노드의 최단 거리 배열의 값)
5. 과정 3~4를 반복해 최단 거리 배열 완성하기
   - 과정 4에서 선택 노드가 될 때마다 다시 선택되지 않도록 방문 배열을 만들어 체크
   - 모든 노드가 선택될 때까지 반복하여 최단 거리 배열을 완성한다.

---

### 벨만-포드
> 그래프에서 최단 거리를 구하는 알고리즘

기능
- 특정출발 노드에서 다른 모든 노드까지의 최단 경로 탐색

특징
- 음수 가중치 엣지가 있어도 수행할 수 있다.
- 전체 그래프에서 음수 사이클의 존재 여부 판단 가능

시간복잡도
- O(VE) (노드 수: V, 엣지 수: E)

핵심 이론
1. 엣지 리스트로 그래프를 구현하고 최단 경로 배열 초기화하기
   - 엣지를 중심으로 동작하므로, 엣지 리스트로 그래프를 구현
     - Edge[] edge;
   - 최단 경로 배열은 출발 노드 0, 나머지는 무한대(최대값)으로 초기화
     - D[]
2. 모든 엣지를 확인해 정답 배열 업데이트
   - 최단 거리 배열에서 업데이트 반복 횟수는 '노드 개수(N) - 1'
     - 노드 개수가 N이고, 음수 사이클이 없을 때 특정 두 노드의 최단 거리를 구성할 수 있지의 최대 개수는 N-1
   - 업데이트 조건
     - D[s] != 무한, D[e] > D[s] + w 일때 D[e] = D[s] + w로 배열의 값을 업데이트
       - s: 출발노드, e: 종료노드, w: 가중치
   - 음수 사이클이 존재하는지 확인
3. 음수 사이클 유무 확인 (중요)
   - 모든 엣지를 한 번씩 다시 사용해 업데이트되는 노드가 발생하는지 확인
   - 업데이트가되는 노드가 있다면 음수 사이클 존재 -> 최단 거리를 찾을 수 없는 그래프가 된다.
     - 음수 사이클이 존재하면 이 사이클을 무한하게 돌수록 가중치가 계속 감소하기 때문 

---

### 플로이드-워셜
> 그래프에서 최단 거리를 구하는 알고리즘

기능
- 모든 노드 간에 최단 경로 탐색

특징
- 음수 가중치 엣지가 있어도 수행할 수 있다.
- 동적 계획법의 원리를 이용해 알고리즘에 접근

시간 복잡도
- O(V^3) (노드 수 : V)

핵심 이론
> A노드에서 B노드까지 최단 경로를 구했다고 가정했을 때, 최단 경로위에 K 노드가 존재한다면 '그것을 이루는 부분 경로 역시 최단 경로이다.'  
> **즉, 전체 경로의 최단 경로는 부분 경로의 최단 경로의 조합으로 이뤄진다는 뜻**

- 플로이드-워셜 점화식
  - D[S][E] = Math.min(D[S][E], D[S][K] + D[K][E])
1. 배열을 선언하고 초기화하기
   - D[S][E] => 노드 S에서 노드 E까지의 최단 거리를 저장하는 배열
   - S, E의 값이 같으면 0(자기 자신에게 가는데 걸리는 시간), 다르면 무한(최댓값)
2. 최단 거리 배열에 그래프 데이터 저장하기
   > 플로이드-워셜은 그래프를 인접행렬로 표현
   - D[S][E] = W로 엣지의 정보를 배열에 입력 (출발 노드 S, 도착 노드 E, 가중치 W)
3. 점화식으로 배열 업데이트
   - 3중 for문의 형태로 반복하면서 배열의 값을 업데이트
   - 플로이드-워셜 알고리즘
     ```
       for 경유지 K에 관해 (1~N) // N: 노드개수
          for 출발 노드 S에 관해 (1~N)
            for 도착 노드 E에 관해 (1~N)
            D[S][E] = Math.min(D[S][E], D[S][K] + D[K][E])
     ```
   - 완성된 배열은 모든 노드 간의 최단 거리를 알려준다.

---

### 최소 신장 트리
> 그래프에서 모든 노드를 연결할 때 사용된 엣지들의 가중치의 합을 최소로 하는 트리

특징
- 사이클이 포함되면 가중치의 합이 최소가 될 수 없으므로 사이클을 포함하지 않는다.
  - 사이클이 존재하면 안되는 특징을 지니고 있기 때문에 유니온 파인트 알고리즘을 내부에 구현해야 한다.
- N개의 노드가 있으면 최소 신장 트리를 구성하는 엣지의 개수는 항상 N-1개다.
- 다른 그래프 알고리즘과 달리, 엣지 리스트의 형태를 이용해 데이터를 담는다.
  - 엣지를 기준으로하기 때문

핵심 이론  
1. 엣지 리스트로 그래프를 구현하고 유니온 파인드 배열 초기화하기
   - 엣지 리스트의 형태로 저장
     - 노드가 아닌 엣지 중심으로 저장하기 때문
     - 엣지(Edge) 클래스는 노드 변수 2개와 가중치 변수로 구성
     - PriorityQueue<Edge>
   - 사이클 처리를 위한 유니온 파인드 배열 초기화
     - 배열의 인덱스를 해당 자리의 값으로 초기화
2. 그래프 데이터를 가중치 기준으로 정렬하기
   - 엣지 리스트에 담긴 그래프를 가중치 기준으로 오름차순 정렬
     - 엣지를 클래스로 표현하면 Comparable을 통해 정렬 방식 구현 가능
3. 가중치가 낮은 엣지부터 연결 시도하기
   - 가중치가 낮은 엣지 부터 순서대로 선택해 연결을 시도
     - 바로 연결하지 않고 이 엣지를 연결했을 때 그래프에 사이클 형성 유무 체크 -> find연산'
       - 사이클 형성 = 두 노드의 대표노드가 같다
     - 사이클 형성되지 않을 때만 union 연산을 이용해 두 노드 연결
4. 과정 3 반복하기
   - 전체 노드의 개수가 N개이면 연결한 엣지의 개수가 N-1이 될 때까지 과정 3반복
5. 총 엣지 비용 출력
   - 엣지의 개수가 N-1이 되면 알고리즘 종료, 완성된 최소 신장 트리의 총 엣지 비용을 출력

---


### 세그먼트 트리

---


### 최소 공통 조상
> 트리 그래프에서 임이의 두 노드를 선택했을 때 두 노드가 각각 자신을 포함해 거슬러 올라가면서 부모 노드를 탐색할때
> 처음 공통으로 만나게 되는 부모노드 '최소 공통 조상(LCA, Lowest Common Ancestor)'

핵심 이론  
**일반적인 최소 공통 조상 구하기**
> 트리의 높이가 크지 않을 때 최소 공통 조상을 구하는 방법  
> 트리의 높이가 커질 경우, 시간이 오래 걸린다.
1. 루트 노드에서 탐색을 시작해 각 노드의 부모 노드와 깊이를 저장한다
2. 선택된 두 노드의 깊이가 다른 경우, 더 깊은 노드의 노드를 부모 노드로 1개씩 올려주면서 같은 깊이로 맞춘다.
   - 이때 두 노드가 같으면 해당 노드가 최소 공통 조상
3. 깊이가 같은 상태에서는 동시에 부모 노드로 올라가면서 두 노드가 같은 노드가 될 때까지 반복
   - 이때 처음 만나는 노드가 최소 공통 조상

**최소 공통 조상 빠르게 구하기**
> 서로의 깊이를 맞춰 주거나 같아지는 노드를 찾을때 2^k씩 올라가 비교하는 방식  
- 일반적인 방식에서 약간 변형한 형태
- 자신의 부모 노드 뿐아니라 2^k번째 위치의 부모 노드까지 저장해야한다.
1. 부모 노드 저장 배열 만들기
   - 부모 노드 배열의 정의 : P[K][N] => N번째 노드의 2^K번째 부모 노드 번호
   - 부모 노드 배열의 점화식 : ```P[K][N] = P[K-1][P[k-1][N]]```
     - N의 2^K번째 부모 노드 = N의 2^K-1번째 부모 노드의 2^K-1번째 부모 노드
   - K의 조건 : ```'2^K < 트리의 깊이'``` 를 만족하는 최댓값
2. 선택된 두 노드의 깊이 맞추기
   - 부모 노드 배열을 이용하여 깊이를 2^K 단위로 넘어가며 높이를 맞춘다.
     - depth1: 2, depth2: 6 => depth2-depth1 = 4 => 4 = 2^k => k = 2
3. 최소 공통 조상 찾기
   - 공통 조상을 찾는 작업도 2^K 단위로 점프하면서 맞춘다.
     - K를 1씩 감소하면서 부모 노드 저장배열을 이용해 최초로 두 노드의 부모가 달라지는 값을 찾는다.
   - 최초로 달라지는 K에 대한 두 노드의 부모 노드를 찾아 이동
   - 반복문이 종료된 후 이동한 2개의 노드가 같은 노드라면 해당 노드가, 다른 노르라면 바로 위의 노드가 최소 공통 조상이 된다.


---


### 조합
**조합(Combination)**
> n개의 숫자에서 r개를 뽑는 경우의 수 (순서를 고려하지 않음)
- nCr로 표현 : ```n! / (n - r)!```
- ex) 5개 숫자에서 2가지를 뽑는 경우의 수 => 5 * 4 / 2 = 10

**순열 (Permutation)**
> n개의 숫자 중 r개를 뽑아 순서를 고려해 나열할 경우의 수
- nPr로 표현 : ```n! / (n - r)!```
- ex) 5개 숫자에서 2가지를 뽑는 경우의 수 => 5 / 4 = 20

핵심 이론 및 구현 방식
1. 특정 문제를 가정하기
2. (중요) 모든 부분 문제가 해결된 상황이라고 가정하고 지금 문제 생각하기
3. 특정 문제를 해결한 내용을 바탕으로 일반 점화식 도출하기
   - **조합 점화식** : ```D[i][j] = D[i =- 1][i] + D[i - 1][j - 1]```

ex) 5개중 3개를 선택하는 경우의 수
- 이미 선택이 완료된 데이터로 가정
  - 5개의 데이터 중 4개를 이미 선택완료된 데이터로 가정
- 모든 부분 문제가 해결된 상황이라고 가정하고 지금 문제 생각하기
  - 마지막 데이터 포함 + 선택이 완료된 데이터 중 2개를 선택하는 경우의 수 : 4C2
  - 마지막 데이터 포함 X + 선택이 완료된 데이터 중 3개를 선택하는 경우의 수 : 4C3
  - 5개 중 3개를 선택하는 경우의 수 5C3 = 4C2 + 4C3

---


### 동적계획법(다이나믹프로그래밍, DP)
> 복잡한 문제를 여러 개의 간단한 문제로 분리하여 부분의 문제들을 해결함으로써 최종적으로 복잡한 문제의 답을 구하는 방법

동적계획법 원리와 구현 방식
1. 큰 문제를 작은 문제로 나눌 수 있어야 한다.
2. 작은 문제들이 반복돼 나타나고 사용되며 이 작은 문제들의 결과 값은 항상 같아야 한다.
3. 모든 작은 문제들은 한 번만 계산해 DP 테이블에 저장하며 추후 재사용할 때는 이 DP 테이블을 이용한다. (메모이제이션 기법)
4. 동적 계획법은 톱-다운(top-down)방식과 바텁-업(bottom-up)방식으로 구현할 수 있다.

대표적인 동적계획법 문제 - **피보나치 수열 공식**
- D[N] = D[N-1] + D[N-2]; // N번째 수열 = N-1번째 수열 + N-2번째 수열


---
